// Generated by dts-bundle-generator v9.0.0

export declare const DataCenterRegionId: {
	readonly Japan: 1;
	readonly America: 2;
	readonly Europe: 3;
	readonly Oceania: 4;
};
export type DataCenterRegionId = (typeof DataCenterRegionId)[keyof typeof DataCenterRegionId];
export declare const DataCenterId: {
	readonly Elemental: 1;
	readonly Gaia: 2;
	readonly Mana: 3;
	readonly Aether: 4;
	readonly Primal: 5;
	readonly Chaos: 6;
	readonly Light: 7;
	readonly Crystal: 8;
	readonly Materia: 9;
	readonly Meteor: 10;
	readonly Dynamis: 11;
};
export type DataCenterId = (typeof DataCenterId)[keyof typeof DataCenterId];
export declare const WorldId: {
	readonly Ravana: 21;
	readonly Bismarck: 22;
	readonly Asura: 23;
	readonly Belias: 24;
	readonly Pandaemonium: 28;
	readonly Shinryu: 29;
	readonly Unicorn: 30;
	readonly Yojimbo: 31;
	readonly Zeromus: 32;
	readonly Twintania: 33;
	readonly Brynhildr: 34;
	readonly Famfrit: 35;
	readonly Lich: 36;
	readonly Mateus: 37;
	readonly Omega: 39;
	readonly Jenova: 40;
	readonly Zalera: 41;
	readonly Zodiark: 42;
	readonly Alexander: 43;
	readonly Anima: 44;
	readonly Carbuncle: 45;
	readonly Fenrir: 46;
	readonly Hades: 47;
	readonly Ixion: 48;
	readonly Kujata: 49;
	readonly Typhon: 50;
	readonly Ultima: 51;
	readonly Valefor: 52;
	readonly Exodus: 53;
	readonly Faerie: 54;
	readonly Lamia: 55;
	readonly Phoenix: 56;
	readonly Siren: 57;
	readonly Garuda: 58;
	readonly Ifrit: 59;
	readonly Ramuh: 60;
	readonly Titan: 61;
	readonly Diabolos: 62;
	readonly Gilgamesh: 63;
	readonly Leviathan: 64;
	readonly Midgardsormr: 65;
	readonly Odin: 66;
	readonly Shiva: 67;
	readonly Atomos: 68;
	readonly Bahamut: 69;
	readonly Chocobo: 70;
	readonly Moogle: 71;
	readonly Tonberry: 72;
	readonly Adamantoise: 73;
	readonly Coeurl: 74;
	readonly Malboro: 75;
	readonly Tiamat: 76;
	readonly Ultros: 77;
	readonly Behemoth: 78;
	readonly Cactuar: 79;
	readonly Cerberus: 80;
	readonly Goblin: 81;
	readonly Mandragora: 82;
	readonly Louisoix: 83;
	readonly Spriggan: 85;
	readonly Sephirot: 86;
	readonly Sophia: 87;
	readonly Zurvan: 88;
	readonly Aegis: 90;
	readonly Balmung: 91;
	readonly Durandal: 92;
	readonly Excalibur: 93;
	readonly Gungnir: 94;
	readonly Hyperion: 95;
	readonly Masamune: 96;
	readonly Ragnarok: 97;
	readonly Ridill: 98;
	readonly Sargatanas: 99;
	readonly Sagittarius: 400;
	readonly Phantom: 401;
	readonly Alpha: 402;
	readonly Raiden: 403;
	readonly Marilith: 404;
	readonly Seraph: 405;
	readonly Halicarnassus: 406;
	readonly Maduin: 407;
};
export type WorldId = (typeof WorldId)[keyof typeof WorldId];
export type DataCenterData = {
	readonly id: DataCenterId;
	readonly name: string;
	readonly color: string;
	readonly regionId: DataCenterRegionId;
};
export type WorldData = {
	readonly id: WorldId;
	readonly name: string;
	readonly dataCenterId: DataCenterId;
};
export interface DataCenter extends DataCenterData {
	compare(another: DataCenter): number;
}
export declare class DataCenterImpl implements DataCenter {
	readonly id: DataCenterId;
	readonly name: string;
	readonly color: string;
	readonly regionId: DataCenterRegionId;
	constructor(init: DataCenterData);
	compare: (another: DataCenter) => number;
}
export declare const TEorzeaDateCategory: {
	readonly YEARS: 1;
	readonly MONTHS: 2;
	readonly DAYS: 3;
	readonly HOURS: 4;
	readonly MINUTES: 5;
	readonly SECONDS: 6;
	readonly MILLISECONDS: 7;
};
export type TEorzeaDateCategory = (typeof TEorzeaDateCategory)[keyof typeof TEorzeaDateCategory];
export declare class EorzeaDate {
	year: number;
	month: number;
	day: number;
	hour: number;
	minute: number;
	second: number;
	millisecond: number;
	constructor(timeStamp?: number);
	clone(): EorzeaDate;
	get epoch(): number;
	toTimeString(): string;
	toDateString(): string;
	toString(): string;
	toJSON(): {
		et: string;
		lt: string;
	};
	toDate(): Date;
	add(value: number, cat: TEorzeaDateCategory): EorzeaDate;
	subtract(value: number, cat: TEorzeaDateCategory): EorzeaDate;
}
export declare const WeatherId: {
	readonly ClearSkies: 1;
	readonly FairSkies: 2;
	readonly Clouds: 3;
	readonly Fog: 4;
	readonly Wind: 5;
	readonly Gales: 6;
	readonly Rain: 7;
	readonly Showers: 8;
	readonly Thunder: 9;
	readonly Thunderstorms: 10;
	readonly DustStorms: 11;
	readonly HeatWaves: 14;
	readonly Snow: 15;
	readonly Blizzards: 16;
	readonly Gloom: 17;
	readonly UmbralWind: 49;
	readonly UmbralStatic: 50;
	readonly MoonDust: 148;
	readonly AstromagneticStorm: 149;
};
export type WeatherId = (typeof WeatherId)[keyof typeof WeatherId];
export type WeatherData = {
	readonly id: WeatherId;
	readonly icon: string;
};
export interface Weather {
	readonly id: number;
	readonly icon: string;
	readonly name: string;
	readonly tts: string;
}
export declare class WeatherImpl implements Weather {
	constructor(data: WeatherData);
	readonly id: number;
	readonly icon: string;
	get name(): string;
	get tts(): string;
}
export declare class EorzeaPeriod {
	start: EorzeaDate;
	end: EorzeaDate;
	constructor(startTimeStamp: number, endTimeStamp: number);
	toLengthString(): string;
	chanceAt(eodate: EorzeaDate): number;
	toJSON(): {
		start: {
			et: string;
			lt: string;
		};
		end: {
			et: string;
			lt: string;
		};
	};
}
export declare class WeatherPeriod extends EorzeaPeriod {
	readonly weatherRateId: number;
	constructor(timeStamp: number, weatherRateId: number);
	get weather(): Weather;
	get prev(): WeatherPeriod;
	get next(): WeatherPeriod;
}
export declare const ExVersionId: {
	readonly ARealmReborn: 0;
	readonly Heavensward: 1;
	readonly Stormblood: 2;
	readonly Shadowbringers: 3;
	readonly Endwalker: 4;
};
export type ExVersionId = (typeof ExVersionId)[keyof typeof ExVersionId];
export type ExVersionData = {
	readonly id: ExVersionId;
	readonly version: number;
	readonly locationClusteringThreshold: number;
	readonly color: string;
};
export interface ExVersion {
	readonly id: ExVersionId;
	readonly version: number;
	readonly locationClusteringThreshold: number;
	readonly color: string;
	readonly name: string;
	readonly tts: string;
}
export declare class ExVersionImpl implements ExVersion {
	constructor(data: ExVersionData);
	readonly id: ExVersionId;
	readonly version: number;
	readonly locationClusteringThreshold: number;
	readonly color: string;
	get name(): string;
	get tts(): string;
}
export type MarkerData = {
	readonly x: number;
	readonly y: number;
	readonly placeNameId: number;
	readonly icon: string;
};
export type ZoneData = {
	readonly id: number;
	readonly regionPlaceNameId: number;
	readonly zonePlaceNameId: number;
	readonly weatherRateId: number;
	readonly sizeFactor: number;
	readonly offsetX: number;
	readonly offsetY: number;
	readonly offsetZ: number;
	readonly markers: MarkerData[];
	readonly exVersionId: number;
};
export type LocationWithFlag = {
	readonly label: string;
	readonly x: number;
	readonly y: number;
	readonly z: number;
	readonly flag: string;
};
export type FieldZoneData = ZoneData & {
	readonly filter?: boolean;
	readonly elite: {
		readonly ids: number[];
		readonly locations: LocationWithFlag[];
	};
	readonly ss?: {
		readonly ids: number[];
		readonly locations: LocationWithFlag[];
	};
	readonly fate?: {
		readonly ids: number[];
	};
};
export type RegionData = {
	readonly key: string;
	readonly zoneIds: number[];
	readonly color: string;
	readonly bgColor: string;
};
export interface Marker {
	readonly x: number;
	readonly y: number;
	readonly name: string;
	readonly icon: string;
}
export declare class MarkerImpl implements Marker {
	constructor(data: MarkerData, zone: Zone);
	private placeNameId;
	readonly x: number;
	readonly y: number;
	get name(): string;
	readonly icon: string;
}
export interface Zone {
	readonly id: number;
	readonly name: string;
	readonly names: string[];
	readonly exVersion: ExVersion;
	toLocalPosXY(pos: {
		x: number;
		y: number;
	}): [
		number,
		number
	];
	toLocalPosXYZ(pos: {
		x: number;
		y: number;
		z: number;
	}): [
		number,
		number,
		number
	];
	toLocalPos(pos: {
		x: number;
		y: number;
		z?: number;
	}): {
		x: number;
		y: number;
		z?: number;
	};
	readonly scale: {
		xMin: number;
		xMax: number;
		xRange: number;
		yMin: number;
		yMax: number;
		yRange: number;
	};
	getWeatherAt(timestamp: number): WeatherImpl;
	getWeatherPeriodAt(timestamp: number): WeatherPeriod;
	readonly markers: Marker[];
}
export declare class ZoneImpl implements Zone {
	constructor(data: ZoneData);
	readonly id: number;
	private regionPlaceNameId;
	private zonePlaceNameId;
	private offsetX;
	private offsetY;
	private offsetZ;
	private sizeFactor;
	private exVersionId;
	private weatherRateId;
	readonly markers: Marker[];
	get name(): string;
	get names(): string[];
	get longName(): string;
	get scale(): {
		xMin: number;
		xMax: number;
		xRange: number;
		yMin: number;
		yMax: number;
		yRange: number;
	};
	get exVersion(): ExVersion;
	toLocalPosXY(pos: {
		x: number;
		y: number;
	}): [
		number,
		number
	];
	toLocalPosXYZ(pos: {
		x: number;
		y: number;
		z: number;
	}): [
		number,
		number,
		number
	];
	toLocalPos(pos: {
		x: number;
		y: number;
		z?: number;
	}): {
		x: number;
		y: number;
		z?: number;
	};
	getWeatherAt(timestamp: number): WeatherImpl;
	getWeatherPeriodAt(timestamp: number): WeatherPeriod;
}
export interface EliteLocation {
	label: string;
	x: number;
	y: number;
	z: number;
	flag: number;
}
export interface SSLocation {
	label: string;
	x: number;
	y: number;
	z: number;
	icon: string;
}
export declare const TMapImage: {
	readonly Default: 0;
	readonly Outline: 1;
	readonly Transparent: 2;
};
export type TMapImage = (typeof TMapImage)[keyof typeof TMapImage];
export declare const TImageSize: {
	readonly Small: 512;
	readonly Middle: 1024;
	readonly Large: 2048;
};
export type TImageSize = (typeof TImageSize)[keyof typeof TImageSize];
export interface FieldZone extends Zone {
	getMapImageUrl(type: TMapImage, size: TImageSize): string;
	getEliteLocationIndices(pos: {
		x: number;
		y: number;
	}, flag: number, threshold: number): number[];
	getMobColors(mobId: number): [
		string,
		string
	];
	readonly filter?: boolean;
	readonly elite: {
		readonly length: number;
		readonly ids: number[];
		readonly sId: number;
		readonly aIds: number[];
		readonly bIds: number[];
		readonly locations: EliteLocation[];
	};
	readonly ss?: {
		readonly ids: number[];
		readonly sId: number;
		readonly bId: number;
		readonly locations: SSLocation[];
	};
	readonly fate?: {
		readonly ids: number[];
	};
	readonly focusRect: {
		readonly x: number;
		readonly y: number;
		readonly width: number;
		readonly height: number;
	};
}
export declare class FieldZoneImpl extends ZoneImpl implements FieldZone {
	readonly filter?: boolean;
	readonly elite: {
		readonly length: number;
		readonly ids: number[];
		readonly sId: number;
		readonly aIds: number[];
		readonly bIds: number[];
		readonly locations: EliteLocation[];
	};
	readonly ss?: {
		readonly ids: number[];
		readonly sId: number;
		readonly bId: number;
		readonly locations: SSLocation[];
	};
	readonly fate?: {
		readonly ids: number[];
	};
	constructor(data: FieldZoneData);
	getMapImageUrl(imageType: TMapImage, imageSize: TImageSize): string;
	loadMapImage(target: HTMLImageElement, imageType?: TMapImage, imageSize?: TImageSize): Promise<void>;
	getEliteLocationIndices(pos: {
		x: number;
		y: number;
	}, flag?: number, // all
	threshold?: number): number[];
	getMobColors(mobId: number): [
		string,
		string
	];
	get focusRect(): {
		x: number;
		y: number;
		width: number;
		height: number;
	};
}
export declare const IconId: {
	readonly Aetheryte: "060453";
	readonly Mob: "060004";
	readonly PartyMember: "060421";
	readonly Player: "060443";
	readonly Mining: "060437";
	readonly Quarrying: "060438";
	readonly Logging: "060432";
	readonly Harvesting: "060433";
	readonly Fishing: "060445";
	readonly Up: "060954";
	readonly Down: "060955";
	readonly Flag: "060561";
	readonly CairnOfReturn: "060905";
	readonly CairnOfReturnActive: "060906";
	readonly CairnOfPassage: "060907";
	readonly CairnOfPassageActive: "060908";
	readonly GoldCoffer: "060913";
	readonly SilverCoffer: "060912";
	readonly BronzeCoffer: "060911";
	readonly PlotGreen: "060403";
	readonly PlotWhite: "060444";
	readonly Pin: "060442";
	readonly PlotYellow: "060424";
	readonly PlotRed: "060422";
	readonly TriangleGreen: "060358";
	readonly TriangleBlue: "060361";
	readonly TriangleYellow: "060360";
	readonly TriangleRed: "060359";
	readonly TrapYellow: "060402";
	readonly TrapRed: "060401";
	readonly Num1: "060918";
	readonly Num2: "060919";
	readonly Num3: "060920";
	readonly Num4: "060921";
	readonly Num5: "060922";
	readonly Num6: "060923";
	readonly Num7: "060924";
	readonly Num8: "060925";
	readonly SB: "SB";
	readonly SS: "SS";
	readonly CheckMine: "CheckMine";
	readonly CheckOthers: "CheckOthers";
	readonly CheckUnknown: "CheckUnknown";
};
export type IconId = (typeof IconId)[keyof typeof IconId];
export declare const TLang: readonly [
	"ja",
	"en",
	"de",
	"fr"
];
export type TLang = (typeof TLang)[number];
export type TMessage = {
	readonly BNpcName: Record<number, string>;
	readonly PlaceName: Record<number, string>;
	readonly ZoneName: Record<number, string>;
	readonly Weather: Record<number, string>;
	readonly Region: Record<string, string>;
	readonly ExVersion: Record<number, string>;
};
export declare const TMobCategory: {
	readonly EliteMark: 1;
	readonly SpecialEliteMark: 2;
	readonly SpecialFATE: 3;
	readonly None: 999;
};
export type TMobCategory = (typeof TMobCategory)[keyof typeof TMobCategory];
export declare const TMobRank: {
	readonly S: 1;
	readonly A: 2;
	readonly B: 3;
	readonly None: 999;
};
export type TMobRank = (typeof TMobRank)[keyof typeof TMobRank];
export type MobData = {
	readonly id: number;
	readonly category: TMobCategory;
	readonly rank: TMobRank;
	readonly zoneIds: number[];
	readonly respawnMinutes?: {
		min: number;
		max: number;
	};
};
export interface Mob {
	readonly id: number;
	readonly name: string;
	readonly tts: string;
	readonly rank: TMobRank;
	readonly category: TMobCategory;
	readonly zoneIds: number[];
	readonly respawnMinutes: {
		min: number;
		max: number;
	};
}
export declare class MobImpl implements Mob {
	constructor(data: MobData);
	id: number;
	rank: TMobRank;
	category: TMobCategory;
	zoneIds: number[];
	get name(): string;
	get tts(): string;
	respawnMinutes: {
		min: number;
		max: number;
	};
}
export interface Region {
	readonly key: string;
	readonly color: string;
	readonly bgColor: string;
	readonly zones: {
		readonly id: number;
		readonly name: string;
	}[];
	readonly name: string;
	readonly tts: string;
}
export declare class RegionImpl implements Region {
	constructor(data: RegionData);
	readonly key: string;
	readonly color: string;
	readonly bgColor: string;
	readonly zones: {
		readonly id: number;
		readonly name: string;
	}[];
	get name(): string;
	get tts(): string;
}
export declare class SpawnPeriod extends EorzeaPeriod {
	readonly subPeriods: EorzeaPeriod[];
	constructor(startTimeStamp: number, endTimeStamp: number, subPeriods: EorzeaPeriod[]);
}
export interface World {
	readonly id: WorldId;
	readonly name: string;
	readonly dataCenterId: DataCenterId;
	readonly longName: string;
	readonly dataCenterName: string;
	compare(another: World): number;
}
export declare class WorldImpl implements World {
	constructor(info: WorldData);
	readonly id: WorldId;
	readonly name: string;
	readonly dataCenterId: DataCenterId;
	get longName(): string;
	get dataCenterName(): string;
	compare: (another: World) => number;
}
declare class ExVersionProvider {
	constructor();
	private exVersionById;
	findExVersion(id: number): ExVersion | undefined;
}
declare const exVersionProvider: ExVersionProvider;
declare class MessageProvider {
	private _lang;
	private _messages;
	private _tts;
	constructor();
	get lang(): TLang;
	get tts(): TMessage | undefined;
	get messages(): TMessage | undefined;
	setLang(lang: TLang): void;
	getBNpcName(id: number, tts?: boolean): string;
	getPlaceNames(id: number): string[];
	getPlaceName(id: number, tts?: boolean): string;
	getZoneNames(id: number): string[];
	getZoneName(id: number, tts?: boolean): string;
	getExVersion(id: number, tts?: boolean): string;
	getWeather(id: number, tts?: boolean): string;
	getRegion(key: string, tts?: boolean): string;
	getWorld(id: WorldId | number): string;
}
declare const messageProvider: MessageProvider;
declare class MobProvider {
	private mobs;
	private srankelites;
	private arankelites;
	private brankelites;
	private specialelites;
	private specialfates;
	constructor();
	findMob: (id: number) => Mob | undefined;
	getSRankEliteMarks: () => Mob[];
	getARankEliteMarks: () => Mob[];
	getBRankEliteMarks: () => Mob[];
	getSpecialEliteMarks: () => Mob[];
	getSpecialFATEs: () => Mob[];
}
declare const mobProvider: MobProvider;
declare class RegionProvider {
	readonly huntRegions: Region[];
	readonly weatherRegions: Region[];
	constructor();
	findRegionOfZone: (zoneId: number) => Region | undefined;
	getHuntRegions: () => Region[];
	getWeatherRegions: () => Region[];
	get DEAULT_HUNT_REGION(): Region;
	get DEAULT_WEATHER_REGION(): Region;
	get DEFAULT_HUNT_ZONE_ID(): number;
	get DEFAULT_WEATHER_ZONE_ID(): number;
}
declare const regionProvider: RegionProvider;
declare class SpawnPeriodProvider {
	getSpawnInfo(mob: Mob, baseTimeStamp: number, isServerReset: boolean): SpawnPeriod;
}
declare const spawnPeriodProvider: SpawnPeriodProvider;
declare class WeatherProvider {
	private weatherById;
	private weatherRateById;
	constructor();
	isSunny(weatherId: WeatherId | number): boolean;
	isRainy(weatherId: WeatherId | number): boolean;
	findWeather: (weatherId: number) => Weather | undefined;
	geWeatherIds: () => Weather[];
	getWeatherAt(timestamp: number, weatherRateId: number): Weather;
}
declare const weatherProvider: WeatherProvider;
declare class WorldProvider {
	private dataCenterById;
	private worldById;
	constructor();
	findDataCenter: (id: DataCenterId | number) => DataCenter | undefined;
	findWorld: (id: WorldId | number) => World | undefined;
	getDataCentersOfRegion: (regionId: DataCenterRegionId | number) => DataCenter[];
	getWorldsOfDataCenter: (dataCenterId: DataCenterId | number) => World[];
	getWorldsOfRegion(regionId: DataCenterRegionId): World[];
	get DEFAULT_WORLD(): World;
	findWorldOrDefault: (id: WorldId | number) => World;
	get DEFAULT_DATACENTER(): DataCenter;
	findDataCenterOrDefault: (id: DataCenterId | number) => DataCenter;
}
declare const worldProvider: WorldProvider;
declare class ZoneProvider {
	private zoneById;
	private fieldZoneById;
	constructor();
	findZone: (id: number) => Zone | undefined;
	findFieldZone: (id: number) => FieldZone | undefined;
	getFieldZones: () => FieldZone[];
}
declare const zoneProvider: ZoneProvider;

export {
	exVersionProvider as ExVersionProvider,
	messageProvider as MessageProvider,
	mobProvider as MobProvider,
	regionProvider as RegionProvider,
	spawnPeriodProvider as SpawnPeriodProvider,
	weatherProvider as WeatherProvider,
	worldProvider as WorldProvider,
	zoneProvider as ZoneProvider,
};

export {};
